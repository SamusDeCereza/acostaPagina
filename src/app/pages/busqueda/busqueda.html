<app-container>

  <h2 class="card-title">Búsqueda en el sitio</h2>

  <!-- Búsqueda simple -->

  <app-card>
    <div class="card-body">
      <label class="card-title">Búsqueda simple (palabras clave)</label>
      <div class="flex gap-3">
        <!--
          [(ngModel)]="query"
          ANALOGÍA: Es como un espejo o un "walkie-talkie" de dos vías.
          1. Si escribes en el input, la variable 'query' en el TS se actualiza.
          2. Si cambias 'query' en el TS, el texto en el input se actualiza.
          ¡Siempre están sincronizados!

          (keyup.enter)="doSearch()"
          ANALOGÍA: Es un "oído" atento. Escucha el evento de soltar la tecla (keyup),
          pero SOLO si esa tecla es ENTER. Si sucede, ejecuta la función doSearch().
        -->
        <input class="input-sm bg-white rounded-sm px-2 lg:w-sm" placeholder="Ej: menú, breadcrumbs, mapa..." [(ngModel)]="query"
          (keyup.enter)="doSearch()" />
        <!-- (click): Escucha cuando el usuario hace clic con el ratón. -->
        <button class="btn btn-primary" (click)="doSearch()">Buscar</button>
        <button class="btn btn-outline btn-secondary" (click)="clear()">Limpiar</button>
      </div>
      <small class="text-muted d-block mt-2">
        Tip: escribe una palabra y presiona Enter.
      </small>
    </div>
  </app-card>

  <!-- Búsqueda avanzada -->
  <app-card>
    <div class="card-body">
      <h5 class="card-title">Búsqueda avanzada (filtros)</h5>

      <div class="flex flex-wrap gap-3 *:flex *:gap-3 *:items-center">
        <div class="">
          <label class="form-label">Tipo</label>
          <!--
            (change)="doSearch()"
            Cada vez que el usuario cambia la opción del select, disparamos la búsqueda automáticamente.
          -->
          <select class="select lg:w-36" [(ngModel)]="filters.type" (change)="doSearch()">
            <option value="todos">Todos</option>
            <option value="pagina">Página</option>
            <option value="seccion">Sección</option>
          </select>
        </div>

        <div class="">
          <label class="form-label">Sección/tema</label>
          <select class="select lg:w-48" [(ngModel)]="filters.section" (change)="doSearch()">
            <option value="todas">Todas</option>
            <!--
              *ngFor="let s of sections"
              ANALOGÍA: Es como una fotocopiadora.
              Toma el elemento <option> y lo repite tantas veces como elementos haya en la lista 'sections'.
              En cada copia, la variable 's' tomará el valor de ese turno.
            -->
            <option *ngFor="let s of sections" [value]="s">{{ s }}</option>
          </select>
        </div>
      </div>

      <small class="text-muted d-block mt-2">
        Los filtros acotan resultados sin necesidad de escribir más palabras.
      </small>
    </div>
  </app-card>

  <!-- Resultados -->
  <app-card>
    <div class="card-body">
      <h5 class="card-title">Resultados</h5>

      <!--
        *ngIf="results$ | async as results"
        ANALOGÍA COMPLEXA:
        1. results$ es el paquete de Amazon que viene en camino (Observable).
        2. | async es el mayordomo que espera en la puerta. Se suscribe, espera el paquete, lo abre y te da el contenido.
           También se encarga de cancelar la suscripción si te vas de la página (evita fugas de memoria).
        3. as results: Le pone etiqueta "results" al contenido ya desempaquetado (el array de datos) para usarlo aquí dentro.
      -->
      <ng-container *ngIf="results$ | async as results">
        <!--
          *ngIf="results.length === 0"
          ANALOGÍA: El oficial de tránsito.
          Si la condición es verdadera (lista vacía), deja pasar al elemento (lo muestra).
          Si es falsa, lo detiene y lo quita del DOM (no existe en la página).
        -->
        <div *ngIf="results.length === 0" class="alert alert-warning mb-0">
          No se encontraron resultados con los criterios actuales.
        </div>

        <ul *ngIf="results.length > 0" class="list bg-base-100 rounded-box overflow-clip">
          <!--
            [routerLink]="item.path"
            Usamos corchetes [] porque "item.path" es una variable, no un texto fijo.
            Esto le dice a Angular: "Evalúa lo que hay adentro de las comillas".
          -->
          <li *ngFor="let item of results" class="list-row w-full flex rounded-none! hover:bg-base-300 ">
            <a [routerLink]="item.path" class="w-full">
              <div class="flex gap-3 justify-between align-items-center">
                <div>
                  <div class="font-semibold">{{ item.title }}</div>
                  <small class="text-muted">{{ item.description }}</small>
                </div>
                <span class="badge bg-accent">
                  {{ item.section }}
                </span>
              </div>
            </a>
          </li>
        </ul>
      </ng-container>

    </div>
  </app-card>

</app-container>